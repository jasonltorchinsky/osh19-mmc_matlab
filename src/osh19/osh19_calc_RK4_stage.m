function stage_out = osh19_calc_RK4_stage(params, grid, bg_profs, stage_in)

stage_out = struct();

% Unpack some commonly used variables
nx = params.nx;
ny = params.ny;
nz = params.nz;

beta      = params.beta;
c_p       = params.c_p;
L_v       = params.L_v;
tau_u     = params.tau_u;
tau_theta = params.tau_theta;
tau_up    = params.tau_up;
tau_mid   = params.tau_mid;

dz = grid.dz;

scale_x = (2 * pi) / (2 * pi * params.P_E);
scale_y = (2 * pi) / (2 * params.P_Y);

% Diagnostic variables
stage_out.zeta_tau = zeros([ny, nx]);
stage_out.u_psi    = zeros([ny, nx, nz + 1]);
stage_out.v_psi    = zeros([ny, nx, nz + 1]);
stage_out.theta    = zeros([ny, nx, nz + 1]);
stage_out.q        = zeros([ny, nx, nz + 1]);
% Prognostic variables
stage_out.tau_z    = zeros([ny, nx]);
stage_out.u_tau    = zeros([ny, nx]);
stage_out.v_tau    = zeros([ny, nx]);
stage_out.u        = zeros([ny, nx, nz + 1]);
stage_out.v        = zeros([ny, nx, nz + 1]);
stage_out.w        = zeros([ny, nx, nz + 1]);
stage_out.p        = zeros([ny, nx, nz + 1]);

% Calculate BT variables
u_tau2    = (stage_in.u_tau).^2;
utau_vtau = stage_in.u_tau .* stage_in.v_tau;
v_tau2    = (stage_in.v_tau).^2;

% Calculate multiples of winds
u2 = (stage_in.u).^2;
uv = stage_in.u .* stage_in.v;
v2 = (stage_in.v).^2;

% Question:  Do we need to take derivative of beta*Y numerically, not analytically???
% Current answer:  Take derivative numerically

% Calculate zeta RHS
stage_out.zeta_tau = -D1(beta * grid.yy, 'y', scale_y) .* stage_in.v_tau ...
    - 1/tau_u * stage_in.zeta_tau ...   
    - D2(utau_vtau,'x','x',scale_x, scale_x) ...
    + D2(utau_vtau,'y','y',scale_y,scale_y) ...
    - D2(v_tau2,'x','y',scale_x,scale_y) ...
    + D2(u_tau2,'x','y',scale_x,scale_y);

for kk = 2:nz   

    % Calculate u RHS
    uavg1 = mean(stage_in.u(:,:,kk:kk+1),3);
    uavg2 = mean(stage_in.u(:,:,kk-1:kk),3);
    stage_out.u_psi(:,:,kk) = beta * grid.yy .* stage_in.v_psi(:,:,kk) ...
        - D1(stage_in.p(:,:,kk),'x',scale_x) ...                                         
        - 1/tau_u * stage_in.u(:,:,kk) ...
        + D1(u_tau2,'x',scale_x) ...
        + D1(utau_vtau,'y',scale_y) ...
        - D1(squeeze(u2(:,:,kk)),'x',scale_x) ...   
        - D1(squeeze(uv(:,:,kk)),'y',scale_y) ...   
        - 1/dz * ( stage_in.w(:,:,kk) .* uavg1 ...
                   - stage_in.w(:,:,kk-1) .* uavg2 ); 

    % Calculate v RHS
    vavg1 = mean(stage_in.v(:,:,kk:kk+1),3);
    vavg2 = mean(stage_in.v(:,:,kk-1:kk),3);
    stage_out.v_psi(:,:,kk) = -beta * grid.yy .* stage_in.u_psi(:,:,kk) ...                    
        - D1(stage_in.p(:,:,kk),'y',scale_y) ...              
        - 1/tau_u * stage_in.v_psi(:,:,kk) ... 
        + D1(utau_vtau,'x',scale_x) ...
        + D1(v_tau2,'y',scale_y) ...
        - D1(squeeze(uv(:,:,kk)),'x',scale_x) ...   
        - D1(squeeze(v2(:,:,kk)),'y',scale_y)...
        - 1/dz * (stage_in.w(:,:,kk) .* vavg1 ...
                  - stage_in.w(:,:,kk-1) .* vavg2);

              % CONTINUE FROM HERE
    % Calculate theta RHS
    stage_out.theta(:,:,kk) = -1/(2*dz) * stage_in.w(:,:,kk) ...
                               .* ( bg_profs.theta_bg_mat(:,:,kk+1) ...
                                    - bg_profs.theta_bg_mat(:,:,kk-1) ) ...
        - 1/tau_theta * stage_in.theta(:,:,kk) ...
        - D1(squeeze(stage_in.theta(:,:,kk)).*uavg1,'x',scale_x) ...   
        - D1(squeeze(stage_in.theta(:,:,kk)).*vavg1,'y',scale_y) ...
        - 1/(2*dz) * ( stage_in.w(:,:,kk+1).*stage_in.theta(:,:,kk+1) ...
                       - stage_in.w(:,:,kk-1).*stage_in.theta(:,:,kk-1));
    if params.clin_conv_adj == 1
        stage_out.theta(:,:,kk) = stage_out.theta(:,:,kk) ...
            + sqrt(2) * L_v / c_p / tau_up ...
              * ( sqrt(3) / nz * sum(stage_in.q(:,:,2:nz) .* bg_profs.sinz_mat,3) ...
                  -4 * sqrt(3) / nz * sum(stage_in.q(:,:,2:nz) .* bg_profs.sin2z_mat,3) ) ...
              .* ( bg_profs.sinz(kk-1) - 1/2 * bg_profs.sin2z(kk-1) ) ...
            + sqrt(2) * L_v/ c_p / tau_mid ...
              * ( sqrt(3) / nz * sum(stage_in.q(:,:,2:nz) .* bg_profs.sinz_mat,3) ...
                  + 4 * sqrt(3) / nz * sum(stage_in.q(:,:,2:nz) .* bg_profs.sin2z_mat,3) ) ...
              .* ( bg_profs.sinz(kk-1) + 1/2 * bg_profs.sin2z(kk-1) );
    elseif params.clin_conv_adj == 2
        stage_out.theta(:,:,kk) = stage_out.theta(:,:,kk) ...
            + sqrt(2) * L_v / c_p / tau_up ...
              * ( sqrt(3) / nz * sum(stage_in.q(:,:,2:nz) .* bg_profs.sinz_mat,3) ...
                  - 4 * sqrt(3) / nz * sum(stage_in.q(:,:,2:nz) .* bg_profs.sin2z_mat,3) ) ...
              .* ( bg_profs.sinz(kk-1) - 1/2 * bg_profs.sin2z(kk-1) ) ...
            + sqrt(2) * L_v / c_p / tau_mid ...
              * ( 2 / nz * sum(stage_in.q(:,:,2:nz) .* bg_profs.sinz_mat,3) )...
              .*( bg_profs.sinz(kk-1) );
    else
        stage_out.theta(:,:,kk) = stage_out.theta(:,:,kk) ...
            + L_v / c_p / bg_profs.tau_vec(kk-1) * stage_in.q(:,:,kk);
    end

    %%%%% MAKE SURE YOU CHECK ANOMALIES VS BACKGROUND STATE HERE %%%%%
    % Calculate q RHS
    stage_out.q(:,:,kk) = -1/(2*dz) * stage_in.w(:,:,kk) ...
                           .* (bg_profs.q_bg_mat(:,:,kk+1) - bg_profs.q_bg_mat(:,:,kk-1)) ...
        + bg_profs.D_h_vec(kk-1) * (D2(stage_in.q(:,:,kk),'x','x',scale_x,scale_x) ...
        + D2(stage_in.q(:,:,kk),'y','y',scale_y,scale_y)) ...
        + bg_profs.D_v_vec(kk-1) / dz^2 ...
          * (stage_in.q(:,:,kk+1) - 2*stage_in.q(:,:,kk) + stage_in.q(:,:,kk-1)) ...
        - D1(squeeze(stage_in.q(:,:,kk)) .* uavg1,'x',scale_x) ...   
        - D1(squeeze(stage_in.q(:,:,kk)) .* vavg1,'y',scale_y) ...
        - vavg1 .* D1(squeeze(bg_profs.q_bg_mat(:,:,kk)),'y',scale_y) ...
        - 1/(2*dz) * ( stage_in.w(:,:,kk+1) .* stage_in.q(:,:,kk+1) ...
                       - stage_in.w(:,:,kk-1) .* stage_in.q(:,:,kk-1) ); 
    if params.clin_conv_adj == 1
        stage_out.q(:,:,kk) = stage_out.q(:,:,kk) ...
            - sqrt(2) / tau_up ...
              * ( sqrt(3) / nz * sum(stage_in.q(:,:,2:nz) .* bg_profs.sinz_mat,3) ...
                  - 4 * sqrt(3) / nz * sum(stage_in.q(:,:,2:nz) .* bg_profs.sin2z_mat,3) ) ...
              .* ( bg_profs.sinz(kk-1) - 1/2 * bg_profs.sin2z(kk-1) )...
            - sqrt(2) / tau_mid ...
              * ( sqrt(3) / nz * sum(stage_in.q(:,:,2:nz) .* bg_profs.sinz_mat,3) ...
                  + 4 * sqrt(3) / nz * sum(stage_in.q(:,:,2:nz) .* bg_profs.sin2z_mat,3)) ...
              .* ( bg_profs.sinz(kk-1) + 1/2 * bg_profs.sin2z(kk-1) );
    elseif params.clin_conv_adj == 2
        stage_out.q(:,:,kk) = stage_out.q(:,:,kk) ...
            - sqrt(2) / tau_up ...
              * ( sqrt(3) / nz * sum(stage_in.q(:,:,2:nz) .* bg_profs.sinz_mat,3) ...
                  - 4 * sqrt(3) / nz * sum(stage_in.q(:,:,2:nz) .* bg_profs.sin2z_mat,3) ) ...
              .* ( bg_profs.sinz(kk-1) - 1/2 * bg_profs.sin2z(kk-1) ) ...
            - sqrt(2) / tau_mid ...
              * ( 2 / nz * sum(stage_in.q(:,:,2:nz) .* bg_profs.sinz_mat,3) ) ...
              .* ( bg_profs.sinz(kk-1) );
    else
        stage_out.q(:,:,kk) = stage_out.q(:,:,kk) ...
            - 1/bg_profs.tau_vec(kk-1) * stage_in.q(:,:,kk);
    end
end

% Dealias output
stage_out.zeta_tau = dealias(stage_out.zeta_tau, 2.0/3.0);
stage_out.u_psi    = dealias(stage_out.u_psi,   2.0/3.0);
stage_out.v_psi    = dealias(stage_out.v_psi,   2.0/3.0);
stage_out.theta    = dealias(stage_out.theta,    2.0/3.0);
stage_out.q        = dealias(stage_out.q,        2.0/3.0);

stage_out = osh19_prognose_state(params, grid, stage_out);
end


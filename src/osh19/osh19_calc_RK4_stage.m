function stage_out = osh19_calc_RK4_stage(params, grid, bg_profs, stage_in)

stage_out = struct();

% Unpack some commonly used variables
nx = params.nx;
ny = params.ny;
nz = params.nz;

beta  = params.beta;
tau_u = params.tau_u;

dz = grid.dz;

scale_x = (2 * pi) / (2 * pi * params.P_E);
scale_y = (2 * pi) / (2 * params.P_Y);

% Diagnostic variables
stage_out.zeta_tau = zeros([ny, nx]);
stage_out.u_psi    = zeros([ny, nx, nz + 1]);
stage_out.v_psi    = zeros([ny, nx, nz + 1]);
stage_out.theta    = zeros([ny, nx, nz + 1]);
stage_out.q        = zeros([ny, nx, nz + 1]);
% Prognostic variables
stage_out.tau_z    = zeros([ny, nx]);
stage_out.u_tau    = zeros([ny, nx]);
stage_out.v_tau    = zeros([ny, nx]);
stage_out.u        = zeros([ny, nx, nz + 1]);
stage_out.v        = zeros([ny, nx, nz + 1]);
stage_out.w        = zeros([ny, nx, nz + 1]);
stage_out.p        = zeros([ny, nx, nz + 1]);

% Calculate BT variables
u_tau2    = (stage_in.u_tau).^2;
utau_vtau = stage_in.u_tau .* stage_in.v_tau;
v_tau2    = (stage_in.v_tau).^2;

% Calculate multiples of winds
u2 = (stage_in.u).^2;
uv = stage_in.u .* stage_in.v;
v2 = (stage_in.v).^2;

% Question:  Do we need to take derivative of beta*Y numerically, not analytically???
% Current answer:  Take derivative numerically

% Calculate zeta RHS
stage_out.zeta_tau = -D1(beta * grid.yy, 'y', scale_y) .* stage_in.v_tau ...
    - 1/tau_u * stage_in.zeta_tau ...   
    - D2(utau_vtau,'x','x',scale_x, scale_x) ...
    + D2(utau_vtau,'y','y',scale_y,scale_y) ...
    - D2(v_tau2,'x','y',scale_x,scale_y) ...
    + D2(u_tau2,'x','y',scale_x,scale_y);

for kk = 2:nz   

    % Calculate u RHS
    uavg1 = mean(stage_in.u(:,:,kk:kk+1),3);
    uavg2 = mean(stage_in.u(:,:,kk-1:kk),3);
    stage_out.u_psi(:,:,kk) = beta * grid.yy .* stage_in.v_psi(:,:,kk) ...
        - D1(stage_in.p(:,:,kk),'x',scale_x) ...                                         
        - 1/tau_u * stage_in.u(:,:,kk) ...
        + D1(u_tau2,'x',scale_x) ...
        + D1(utau_vtau,'y',scale_y) ...
        - D1(squeeze(u2(:,:,kk)),'x',scale_x) ...   
        - D1(squeeze(uv(:,:,kk)),'y',scale_y) ...   
        - 1/dz * ( stage_in.w(:,:,kk) .* uavg1 ...
                   - stage_in.w(:,:,kk-1) .* uavg2 ); 

    % Calculate v RHS
    vavg1 = mean(stage_in.v(:,:,kk:kk+1),3);
    vavg2 = mean(stage_in.v(:,:,kk-1:kk),3);
    stage_out.v_psi(:,:,kk) = -beta * grid.yy .* stage_in.u_psi(:,:,kk) ...                    
        - D1(stage_in.p(:,:,kk),'y',scale_y) ...              
        - 1/tau_u * stage_in.v_psi(:,:,kk) ... 
        + D1(utau_vtau,'x',scale_x) ...
        + D1(v_tau2,'y',scale_y) ...
        - D1(squeeze(uv(:,:,kk)),'x',scale_x) ...   
        - D1(squeeze(v2(:,:,kk)),'y',scale_y)...
        - 1/dz * (stage_in.w(:,:,kk) .* vavg1 ...
                  - stage_in.w(:,:,kk-1) .* vavg2);

              % CONTINUE FROM HERE
    % Calculate theta RHS
    stage_out.theta(:,:,kk) = -1/(2*dz) * stage_in.w(:,:,kk) ...
                                        .*(thetatildemat(:,:,kk+1)-thetatildemat(:,:,kk-1))...
        -1/tau_theta*thanomtemp(:,:,kk)...
        -D1(squeeze(thanomtemp(:,:,kk)).*uavg1,'x',scale_x)...   
        -D1(squeeze(thanomtemp(:,:,kk)).*vavg1,'y',scale_y)...
        -1/(2*dz)*(stage_in.w(:,:,kk+1).*thanomtemp(:,:,kk+1)-stage_in.w(:,:,kk-1).*thanomtemp(:,:,kk-1)); %...
    if use_2BCConvAdj==1
        theta(:,:,kk)=theta(:,:,kk)...
            +sqrt(2)*Lv/cp/tau_upper*(sqrt(3)/nz*sum(qanomtemp(:,:,2:nz).*sinzmat,3)-4*sqrt(3)/nz*sum(qanomtemp(:,:,2:nz).*sin2zmat,3))...
            .*(sinzvec(kk-1)-1/2*sin2zvec(kk-1))...
            +sqrt(2)*Lv/cp/tau_lower*(sqrt(3)/nz*sum(qanomtemp(:,:,2:nz).*sinzmat,3)+4*sqrt(3)/nz*sum(qanomtemp(:,:,2:nz).*sin2zmat,3))...
            .*(sinzvec(kk-1)+1/2*sin2zvec(kk-1));
    elseif use_2BCConvAdj==2
        theta(:,:,kk)=theta(:,:,kk)...
            +sqrt(2)*Lv/cp/tau_upper*(sqrt(3)/nz*sum(qanomtemp(:,:,2:nz).*sinzmat,3)-4*sqrt(3)/nz*sum(qanomtemp(:,:,2:nz).*sin2zmat,3))...
            .*(sinzvec(kk-1)-1/2*sin2zvec(kk-1))...
            +sqrt(2)*Lv/cp/tau_lower*(2/nz*sum(qanomtemp(:,:,2:nz).*sinzmat,3))...
            .*(sinzvec(kk-1));
    else
        theta(:,:,kk)=theta(:,:,kk)+Lv/cp/tauvec(kk-1)*qanomtemp(:,:,kk);
    end

    %%%%% MAKE SURE YOU CHECK ANOMALIES VS BACKGROUND STATE HERE %%%%%
    % Calculate q RHS
    qRHS(:,:,kk)=qRHS(:,:,kk)...
        -1/(2*dz)*stage_in.w(:,:,kk).*(qbgmat(:,:,kk+1)-qbgmat(:,:,kk-1))...
        +bvec(kk-1)*(D2(qanomtemp(:,:,kk),'x','x',scale_x,scale_x)+D2(qanomtemp(:,:,kk),'y','y',scale_y,scale_y))...
        +Dvvec(kk-1)/dz^2*(qanomtemp(:,:,kk+1)-2*qanomtemp(:,:,kk)+qanomtemp(:,:,kk-1))...
        -D1(squeeze(qanomtemp(:,:,kk)).*uavg1,'x',scale_x)...   
        -D1(squeeze(qanomtemp(:,:,kk)).*vavg1,'y',scale_y)...
        -vavg1.*D1(squeeze(qbgmat(:,:,kk)),'y',scale_y)...
        -1/(2*dz)*(stage_in.w(:,:,kk+1).*qanomtemp(:,:,kk+1)-stage_in.w(:,:,kk-1).*qanomtemp(:,:,kk-1)); %...
    if use_2BCConvAdj==1
        qRHS(:,:,kk)=qRHS(:,:,kk)...
            -sqrt(2)/tau_upper*(sqrt(3)/nz*sum(qanomtemp(:,:,2:nz).*sinzmat,3)-4*sqrt(3)/nz*sum(qanomtemp(:,:,2:nz).*sin2zmat,3))...
            .*(sinzvec(kk-1)-1/2*sin2zvec(kk-1))...
            -sqrt(2)/tau_lower*(sqrt(3)/nz*sum(qanomtemp(:,:,2:nz).*sinzmat,3)+4*sqrt(3)/nz*sum(qanomtemp(:,:,2:nz).*sin2zmat,3))...
            .*(sinzvec(kk-1)+1/2*sin2zvec(kk-1));
    elseif use_2BCConvAdj==2
        qRHS(:,:,kk)=qRHS(:,:,kk)...
            -sqrt(2)/tau_upper*(sqrt(3)/nz*sum(qanomtemp(:,:,2:nz).*sinzmat,3)-4*sqrt(3)/nz*sum(qanomtemp(:,:,2:nz).*sin2zmat,3))...
            .*(sinzvec(kk-1)-1/2*sin2zvec(kk-1))...
            -sqrt(2)/tau_lower*(2/nz*sum(qanomtemp(:,:,2:nz).*sinzmat,3))...
            .*(sinzvec(kk-1));
    else
        qRHS(:,:,kk)=qRHS(:,:,kk)-1/tauvec(kk-1)*qanomtemp(:,:,kk);
    end
end

% Dealias output
u=dealias(u,2.0/3.0);
stage_out.v=dealias(stage_out.v,2.0/3.0);
qRHS=dealias(qRHS,2.0/3.0);
theta=dealias(theta,2.0/3.0);
zeta_tau=dealias(zeta_tau,2.0/3.0);

end

